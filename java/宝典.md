## 1、Java中哪些类不能被继承？

不能被继承的是那些被final关键字修饰的类，一些比较基本的类型或是一些防止扩展类无意间被破坏的类型都应该是final的，在Java中，System、String、StringBuffer等都是不能被继承的。

## 2、String是基本的数据类型吗？

基本数据类型：byte（字节型）  int（整型）  short（短整型）long（长整型） float（单精度浮点型） double（双精度浮点型） char（字符型） boolean（布尔型）  

java.lang.String 是被final关键字修饰的类，不能被继承，不能修改这个类。为了提高效率节省空间，应该使用StringBuffer。

## 3、String s="Hello"; s=s+“world！”;这两行代码执行后，原始的String对象中的内容到底变了没有？

![1552131355543](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552131355543.png)

![1552131397456](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552131397456.png)

没有，String是被关键字final修饰的类，被final修饰的类不可被修改，实例的信息在创建的时候提供，并且在整个生命周期中都不可被改变。

在上面的代码中，s指向一个String对象，在进行+操作后，s所指向的对象“Hello”并没有改变，还在内存中，只是s的指向变了，不再指向对象“Hello”了，而是指向“Hello world!”

通过上面的说明，我们可以得出一个结论：如果经常对字符串进行各种各样修改，或者说不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。这时候，我们应该考虑使用StringBuffer。

![1552132723269](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552132723269.png)

## 4、Java中==和equal的区别

物理的内存是线性结构，并不存在拥有不同功能的不同区域。编译器（或者JVM）为了更高效的处理数据，会用不同的算法把内存分为各种区域，不同的区域拥有各自的特性，Java中，内存可以分为栈、堆、静态域和常量池。

不同的内存区域的功能和特点：

（1）栈区：存放局部变量（变量名、对象的引用等）特点：内存随着函数的调用而开辟，随着函数调用结束而释放

（2）堆区：存放对象（也就是new出来的东西）特点：可以跨函数使用，每个对象有自己对应的存储空间

（3）静态域：存放在对象中用static定义的静态成员

（4）常量池：存放常量 （常量池指的是在编译期被确定，并保存在自己编译的.class文件中的一些数据）

![1552133749873](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552133749873.png)

值类型存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。

==操作比较的是两个变量的值是不是相等，对于引用变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。（地址）

equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是不是相同。（值）

== 比较的是两个对象的地址，而equals比较的是两个对象的内容。

## 5、String和StringBuffer的区别

简单来说，就是一个变量和常量的区别，StringBuffer对象的内容可以更改；而String对象一旦产生后就不可以被更改，重新赋值就是两个对象。

StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理的时候，不生成新的对象，在内存使用上要优于String类，所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更适合一些。

String：在String类中没有用来改变已有字符串中某个字符的方法，由于不能改变一个Java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的，然而，不可改变的字符串具有一个很大的优点：编译器可以把字符串设为共享的。

## 6、String s = new String("xyz")；创建了几个String Object？二者之间的区别是什么？

创建了2个String对象，第一个对象是字符串常量“xyz”，第二个对象是new String("xyz")的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容指向字符串常量“xyz”，另外还有一个引用，指向第二个对象，这是一个变量，在栈中分配内存。

## 7、静态变量与实例变量的区别？

在语法定义上的区别：静态变量前面要加static关键字，而实例变量前面则不加

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也被称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象类使用，静态变量则可以直接使用类名来引用。

## 8、Java中使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

## 9、Integer和int的种种比较？

int是Java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是Java为int提供的封装类。int的默认值是0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0 的区别，int则无法表达出未赋值的情况。另外Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

## 10、构造器Constructor是否可以被重写Override？

构造器Constructor不能被继承，因此不能被重写Override，但是可以被重载Overload

Constructor不能被继承，所以Constructor也就不能被Override，每一个类必须有自己的构造函数，负责构造自己这部分的构造，子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造器。

（1）构造器是干什么用的？（What）

构造器是用来生成一个类的实例时用来初始化这个实例

（2）构造器如何工作？（how）

Java在构造实例时的顺序是这样的：

a、分配对象空间，并将对象中的成员初始化为0或者空，Java不允许用户操纵一个不定值的对象。

b、执行属性值的显式初始化

c、执行构造器

d、将变量关联到堆中的对象上

（3）构造器不能被Override

构造器不是方法，那么用来修饰方法特性的所有修饰符都不能用来修饰构造器，构造器只能用public private protected这三个权限修饰符，且不能有返回语句。

## 11、面向对象的特征有哪些方面？

面向对象的编程语言有封装、继承、多态、抽象等四个主要特征

（1）封装：封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部分的“高内聚、低耦合”，防止程序互相依赖性而带来的变动的影响。在面向对象的编程语言中，对象是封装的基本单位。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。

把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。

（2）抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一类，这个类只考虑这些事物的共性和相似之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。

（3）继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的东西或修改原来的方法使之更加适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。

（4）多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中的实现的方法，必须由程序运行时才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该调用的基本方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。

面向对象编程有三大特性：封装、继承、多态

​	封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据，对外界而言它的内部细节是隐藏的，暴漏给外界的只是它的访问方法。

​	继承为了重用父类代码，两个类若存在IS-A的关系就可以使用继承，同时继承也为实现多态做了铺垫。

​        所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

（5）多态的实现

a、实现条件：

​	继承在为多态的实现做了准备，子类Child继承父类Father，我们可以编写一个指向子类对象的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态就是相同的消息使得不同的类做出不同的响应。

​	Java实现多态的三个必要条件：继承、重写、向上转型

继承：在多态中必须存在继承关系的子类和父类

重写：子类对父类中某些方法进行重新定义，在调用这些方法的时候会调用子类的方法。

向上转型：在多态中需要将子类的引用赋给父类对象，只有这样改引用才能够具备既能调用父类的方法和子类的方法。

只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

b、实现形式

在Java中有两种形式可以实现多态：继承和接口

b1、基于继承实现的多态

基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某个方法的重写，多个子类对同一方法的重写可以表现出不同的行为

b2、基于接口实现的多态

继承是通过重写父类的同一方法的几个不同子类来实现的，那么就可通过实现接口并覆盖接口中的同一方法的几个不同的类体现的。

​        在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

​      继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。

## 12、抽象类（abstract）和接口（interface）的区别？

含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的，abstract class类中定义抽象方法必须在具体的子类中实现，所以不能有抽象构造方法或抽象静态方法，如果子类没有实现抽象父类中的所有抽象方法，那么子类必须定义为abstract类型。

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的，接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认是public static final

两者的语法区别：

（1）、抽象类可以有构造方法，接口中不能有构造方法

（2）、抽象类中可以有普通的成员变量，接口中没有普通成员变量

（3）、抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

（4）、抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

（5）、 抽象类中可以包含静态方法，接口中不能包含静态方法

（6）、 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

（7）、一个类可以实现多个接口，但只能继承一个抽象类。接口更多的是在系统架构设计方法上发挥作用，主要用于定义模块之间的通信契约，而抽象类在代码实现方面发挥作用，可以实现代码的重用。

13、abstract的method是否可同时是static，是否可同时是native，是否可以同时是synchronized？

（1）abstract是抽象的，指的是方法只有声明而没有实现，它的实现要放入声明该类的子类中实现。

（2）static是静态的，是一种属于类而不属于对象的方法或者属性

（3）synchronized是同步，是一种相对线程的锁。

（4）native本地方法，这种方法和抽象方法及其类似，他也只有方法声明，没有方法实现，但是它与抽象方法不同的是，它把具体实现移交给了本地系统的函数库，而没有通过虚拟机，可以说是Java与其他语言通讯的一种机制。

首先abstract与static不能同时用，声明static说明可以直接用类名调用该方法，声明abstract说明需要子类重写该方法，如果同时声明static和abstract，用类名调用一个抽象方法肯定不行。

synchronized 是同步，然而同步是需要有具体操作才能同步的，如果像abstract只有方法声明，那同步一些什么东西就会成为一个问题了，当然抽象方法在被子类继承以后，可以添加同步。
native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个把方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢！

不能放在一起的修饰符：final和abstract，private和abstract，static和abstract，因为abstract修饰的方法是必须在其子类中实现（覆盖），才能以多态方式调用，以上修饰符在修饰方法时期子类都覆盖不了这个方法，final是不可以覆盖，private是不能够继承到子类，所以也就不能覆盖，static是可以覆盖的，但是在调用时会调用编译时类型的方法，因为调用的是父类的方法，而父类的方法又是抽象的方法，又不能够调用，所以上的修饰符不能放在一起。









