## 1、Java中哪些类不能被继承？

不能被继承的是那些被final关键字修饰的类，一些比较基本的类型或是一些防止扩展类无意间被破坏的类型都应该是final的，在Java中，System、String、StringBuffer等都是不能被继承的。

## 2、String是基本的数据类型吗？

基本数据类型：byte（字节型）  int（整型）  short（短整型）long（长整型） float（单精度浮点型） double（双精度浮点型） char（字符型） boolean（布尔型）  

java.lang.String 是被final关键字修饰的类，不能被继承，不能修改这个类。为了提高效率节省空间，应该使用StringBuffer。

## 3、String s="Hello"; s=s+“world！”;这两行代码执行后，原始的String对象中的内容到底变了没有？

![1552131355543](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552131355543.png)

![1552131397456](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552131397456.png)

没有，String是被关键字final修饰的类，被final修饰的类不可被修改，实例的信息在创建的时候提供，并且在整个生命周期中都不可被改变。

在上面的代码中，s指向一个String对象，在进行+操作后，s所指向的对象“Hello”并没有改变，还在内存中，只是s的指向变了，不再指向对象“Hello”了，而是指向“Hello world!”

通过上面的说明，我们可以得出一个结论：如果经常对字符串进行各种各样修改，或者说不可预见的修改，那么使用String来代表字符串的话会引起很大的内存开销。这时候，我们应该考虑使用StringBuffer。

![1552132723269](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552132723269.png)

## 4、Java中==和equal的区别

物理的内存是线性结构，并不存在拥有不同功能的不同区域。编译器（或者JVM）为了更高效的处理数据，会用不同的算法把内存分为各种区域，不同的区域拥有各自的特性，Java中，内存可以分为栈、堆、静态域和常量池。

不同的内存区域的功能和特点：

（1）栈区：存放局部变量（变量名、对象的引用等）特点：内存随着函数的调用而开辟，随着函数调用结束而释放

（2）堆区：存放对象（也就是new出来的东西）特点：可以跨函数使用，每个对象有自己对应的存储空间

（3）静态域：存放在对象中用static定义的静态成员

（4）常量池：存放常量 （常量池指的是在编译期被确定，并保存在自己编译的.class文件中的一些数据）

![1552133749873](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1552133749873.png)

值类型存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。

==操作比较的是两个变量的值是不是相等，对于引用变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。（地址）

equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是不是相同。（值）

== 比较的是两个对象的地址，而equals比较的是两个对象的内容。

## 5、String和StringBuffer的区别

简单来说，就是一个变量和常量的区别，StringBuffer对象的内容可以更改；而String对象一旦产生后就不可以被更改，重新赋值就是两个对象。

StringBuffer的内部实现方式和String不同，StringBuffer在进行字符串处理的时候，不生成新的对象，在内存使用上要优于String类，所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更适合一些。

String：在String类中没有用来改变已有字符串中某个字符的方法，由于不能改变一个Java字符串中的某个单独字符，所以在JDK文档中称String类的对象是不可改变的，然而，不可改变的字符串具有一个很大的优点：编译器可以把字符串设为共享的。

## 6、String s = new String("xyz")；创建了几个String Object？二者之间的区别是什么？

创建了2个String对象，第一个对象是变量s，第二个对象是new String("xyz")的时候产生的，在堆中分配内存给这个对象，只不过这个对象的内容指向字符串常量“xyz”，另外还有一个引用，指向第二个对象，这是一个变量，在栈中分配内存。

## 7、静态变量与实例变量的区别？

在语法定义上的区别：静态变量前面要加static关键字，而实例变量前面则不加

在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也被称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象类使用，静态变量则可以直接使用类名来引用。

## 8、Java中使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？

使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。

## 9、Integer和int的种种比较？

int是Java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是Java为int提供的封装类。int的默认值是0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0 的区别，int则无法表达出未赋值的情况。另外Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。

## 10、构造器Constructor是否可以被重写Override？

构造器Constructor不能被继承，因此不能被重写Override，但是可以被重载Overload

Constructor不能被继承，所以Constructor也就不能被Override，每一个类必须有自己的构造函数，负责构造自己这部分的构造，子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造器。

（1）构造器是干什么用的？（What）

构造器是用来生成一个类的实例时用来初始化这个实例

（2）构造器如何工作？（how）

Java在构造实例时的顺序是这样的：

a、分配对象空间，并将对象中的成员初始化为0或者空，Java不允许用户操纵一个不定值的对象。

b、执行属性值的显式初始化

c、执行构造器

d、将变量关联到堆中的对象上

（3）构造器不能被Override

构造器不是方法，那么用来修饰方法特性的所有修饰符都不能用来修饰构造器，构造器只能用public private protected这三个权限修饰符，且不能有返回语句。

## 11、面向对象的特征有哪些方面？

面向对象的编程语言有封装、继承、多态、抽象等四个主要特征

（1）封装：封装是保证软件部件具有优良的模块性的基础，封装的目标就是要实现软件部分的“高内聚、低耦合”，防止程序互相依赖性而带来的变动的影响。在面向对象的编程语言中，对象是封装的基本单位。面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。

把握一个原则：把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。

（2）抽象：抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一类，这个类只考虑这些事物的共性和相似之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。例如，看到一只蚂蚁和大象，你能够想象出它们的相同之处，那就是抽象。抽象包括行为抽象和状态抽象两个方面。

（3）继承：在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的东西或修改原来的方法使之更加适合特殊的需要，这就是继承。继承是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。

（4）多态：多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中的实现的方法，必须由程序运行时才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该调用的基本方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态性增强了软件的灵活性和扩展性。

面向对象编程有三大特性：封装、继承、多态

​	封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据，对外界而言它的内部细节是隐藏的，暴漏给外界的只是它的访问方法。

​	继承为了重用父类代码，两个类若存在IS-A的关系就可以使用继承，同时继承也为实现多态做了铺垫。

​        所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

（5）多态的实现

a、实现条件：

​	继承在为多态的实现做了准备，子类Child继承父类Father，我们可以编写一个指向子类对象的父类类型引用，该引用既可以处理父类Father对象，也可以处理子类Child对象，当相同的消息发送给子类或者父类对象时，该对象就会根据自己所属的引用而执行不同的行为，这就是多态。即多态就是相同的消息使得不同的类做出不同的响应。

​	Java实现多态的三个必要条件：继承、重写、向上转型

继承：在多态中必须存在继承关系的子类和父类

重写：子类对父类中某些方法进行重新定义，在调用这些方法的时候会调用子类的方法。

向上转型：在多态中需要将子类的引用赋给父类对象，只有这样改引用才能够具备既能调用父类的方法和子类的方法。

只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。

b、实现形式

在Java中有两种形式可以实现多态：继承和接口

b1、基于继承实现的多态

基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某个方法的重写，多个子类对同一方法的重写可以表现出不同的行为

b2、基于接口实现的多态

继承是通过重写父类的同一方法的几个不同子类来实现的，那么就可通过实现接口并覆盖接口中的同一方法的几个不同的类体现的。

​        在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。

​      继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。

## 12、抽象类（abstract）和接口（interface）的区别？

含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的，abstract class类中定义抽象方法必须在具体的子类中实现，所以不能有抽象构造方法或抽象静态方法，如果子类没有实现抽象父类中的所有抽象方法，那么子类必须定义为abstract类型。

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的，接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认是public static final

两者的语法区别：

（1）、抽象类可以有构造方法，接口中不能有构造方法

（2）、抽象类中可以有普通的成员变量，接口中没有普通成员变量

（3）、抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。

（4）、抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

（5）、 抽象类中可以包含静态方法，接口中不能包含静态方法

（6）、 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

（7）、一个类可以实现多个接口，但只能继承一个抽象类。接口更多的是在系统架构设计方法上发挥作用，主要用于定义模块之间的通信契约，而抽象类在代码实现方面发挥作用，可以实现代码的重用。

13、abstract的method是否可同时是static，是否可同时是native，是否可以同时是synchronized？

（1）abstract是抽象的，指的是方法只有声明而没有实现，它的实现要放入声明该类的子类中实现。

（2）static是静态的，是一种属于类而不属于对象的方法或者属性

（3）synchronized是同步，是一种相对线程的锁。

（4）native本地方法，这种方法和抽象方法及其类似，他也只有方法声明，没有方法实现，但是它与抽象方法不同的是，它把具体实现移交给了本地系统的函数库，而没有通过虚拟机，可以说是Java与其他语言通讯的一种机制。

首先abstract与static不能同时用，声明static说明可以直接用类名调用该方法，声明abstract说明需要子类重写该方法，如果同时声明static和abstract，用类名调用一个抽象方法肯定不行。

synchronized 是同步，然而同步是需要有具体操作才能同步的，如果像abstract只有方法声明，那同步一些什么东西就会成为一个问题了，当然抽象方法在被子类继承以后，可以添加同步。
native，这个东西本身就和abstract冲突，他们都是方法的声明，只是一个把方法实现移交给子类，另一个是移交给本地操作系统。如果同时出现，就相当于即把实现移交给子类，又把实现移交给本地操作系统，那到底谁来实现具体方法呢！

不能放在一起的修饰符：final和abstract，private和abstract，static和abstract，因为abstract修饰的方法是必须在其子类中实现（覆盖），才能以多态方式调用，以上修饰符在修饰方法时期子类都覆盖不了这个方法，final是不可以覆盖，private是不能够继承到子类，所以也就不能覆盖，static是可以覆盖的，但是在调用时会调用编译时类型的方法，因为调用的是父类的方法，而父类的方法又是抽象的方法，又不能够调用，所以上的修饰符不能放在一起。

## 13、Object类与哪些方法？

Object类是一个特殊的类，是所有类的父类，主要提供下列11种方法：

（1）public final native Class<?> **getClass**()  //native方法，用于返回当前运行时对象的Class对象，使用final关键字修饰，故不允许子类重写；

（2）public native int **hashCode**()   //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如jdk中的hashMap

（3）public boolean **equals**(Object obj)  //用于比较两个对象的内存地址是否相等，String类对该方法进行了重写，用于比较字符串的值是否相等

（4）protected native Object **clone** throws CloneNotSupportedException //native方法，用于创建并返回当前对象的一份拷贝，一般情况下，对于任何对象x， x.clone() != x 为true，x.clone.getClass == x.getClass为true，Object本身没有实现Cloneable接口，所以不重写Cloneable方法直接调用的话会出现CloneNotSupportException异常

（5）public String **toString**  //返回类的名字@实例的哈希码的16进制的字符串，建议Object的所有子类都重写这个方法；

（6）public final native void **notify**（）    //native方法，并且不能够被重写，用于唤醒一个在此对象监视器上等待的线程（监视器相当于就是锁的概念），如果有多个线程在等待，只会任意唤醒一个；

（7）public final native void **notifyAll**（）  //native方法，并且不能够被重写，与notify的唯一区别就是，它用于唤醒所以在此对象监视器上等待的所有线程，不是一个；

（8）public final native void **wait**(long timeout) throws InterruptedExcepted  //native方法，并且不能够被重写，暂停线程的执行；注意：sleep方法没有释放锁，wait方法释放了锁，timeout是等待时间

（9）public final native void **wait**(long timeout,int nanos) throws InterruptedExcepted  //多了个nanos参数，这个参数表示额外时间（以毫秒为单位，范围为0-999999），所以超时的时候还要加上nanos;

(10)public final void **wait**() throws InterruptedExcepted  //跟之前两个wait方法相比，该方法会一直等待，没有超时的概念；

（11）protected void **finalize**() throws Throwable{}  //实例被垃圾回收的时候触发的操作

## 14、hashCode和equals

（1）hashCode介绍

hashCode的作用是获取哈希码，也称为散列值，它实际上返回的是一个int整数值，这个哈希码的作用是用于确定该对象在哈希表中的索引位置

hashCode定义在JDK的Object.java 中，这就意味着Java中任何类都有hashCode（）函数，另外需要注意的是，hashCode方法是本地方法，也就是用C语言或c++实现的，该方法通常用来将对象的内存地址转换为一个整数之后返回

public native int hashCode（）；

散列表存储的是键值对（key-value），它的特点是能够根据”键“值快速的查找出对应的”值“，这其中就利用了散列码（可以快速找到所需要的对象）

（2）为什么要有hashCode？

我们以”hashSet如何检查重复“为例子来说明为什么要有hashCode

当我们把对象加入hashSet的时候，hashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已加入的hashCode值作比较，如果没有相同的hashCode，会假设没有出现重复的对象，但是如果发现有相同hashCode值的对象，这时会调用equals（）方法来确认相同hashCode值的对象是否真的相同，如果相同，hashSet就不会让其加入，如果不同的话，就会重新让其散列到其他位置，这样就大大减少了equals的次数，大大提高了执行效率。

（3）hashCode和equals的相关规定

如果两个对象相等，则hashCode也一定是相同的

两个对象相等，对两个对象分别调用equals方法都返回true；

两个对象有相同的hashCode值，他们也不一定是相等的；

因此，equals方法被覆盖过，则hashCode方法也必须被覆盖；

hashCode()默认行为是对堆上的对象产生一个独特值，如果没有重写hashCode，则该Class的两个对象无论如何都不会相等（即使这两个对象指向同样的数据）

（4）为什么两个对象有相同的hashCode，也不一定是相等的？

因为hashCode采用的杂凑算法也会让多个对象传回相同的杂凑值，越糟糕的杂凑算法越容易出现碰撞，这也与数据的值域分布有关（所谓碰撞就是不同的对象得到相同的hashCode）

hashSet在对比的时候，如果多个对象的hashCode相等的时候，会采用equals来判断是否真的相等，也就是说hashCode只是用来缩小查找成本的。

（5）==与equals

**==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

**equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。

情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。

## 15、hashMap

hashMap主要用来存放键值对，它是基于hash表的Map接口实现的，是常用的接口之一，与hashTable主要的区别是Hashtable不支持同步和允许null作为key和value，HashMap不是线程安全的，所以如果要想保证线程安全，可以使用ConcurrentHashMap代替HashTable，HashTable基本已经被淘汰。

**内部结构分析**

**jdk1.8之前：**

jdk1.8之前HashMap底层采用数组和链表结合的形式，即链表散列；HashMap通过key的hashCode来获取hash值，当hashCode相同时，采用”拉链法“解决冲突

拉链法：就是将数组和链表结合，也就是常见一个链表数组，数组的每一格就是一个链表，当发生hash冲突的时候，就把冲突的值放到链表中

![1553674192795](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1553674192795.png)



简单来说，jdk1.8之前HashMap由数组+链表组成，数组是HashMap的主体，链表主要是为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找.

**jdk1.8之后**

相比于之前的版本，jdk1.8在解决哈希冲突的时候有很大变化，当链表长度大于阈值时（默认是8），将链表转化为红黑树，以减少搜索时间。

![1553674751518](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1553674751518.png)

## 16、ConcurrentHashMap相关问题

### 16.1ConcurrentHashMap和HashTable的区别

ConcurrentHashMap与HashTable的主要区别体现在线程安全的实现方式上

**底层数据结构**：

jdk1.7的ConcurrentHashMap底层采用分段的数组+链表实现，jdk1.8采用的结构跟HashMap的结构一样，数组+链表/红黑二叉树。

HashTable的结构和1.8之前的HashMap底层数据结构类似，都是采用了数组+链表的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的

**实现线程安全的方式（重要）**

（1）在jdk1.7的时候，ConcurrentHashMap（分段锁）对整个桶数组进行了分割分段（Segment），每一把锁只锁容器中的一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提供并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍），到了jdk1.8的时候，已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作，（jdk1.6以后对synchronized锁做了很多优化）整个看起来是优化过且线程安全的HashMap，虽然在jdk1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧的版本；

（2）Hashtable（同一把锁）采用synchronized来保证线程安全性，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如果使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越激烈效率越低。

两者的对比图：

![1553685466148](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1553685466148.png)

![1553685489875](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1553685489875.png)

![1553685510052](C:\Users\331122.INTERNET\AppData\Roaming\Typora\typora-user-images\1553685510052.png)

### 16.2ConcurrentHashMap线程安全的具体实现方式/底层具体实现

jdk1.7时，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问 其中一个数据段时，其他数据段也能被其他线程访问。

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成

Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。

```
static class Segment<K,V> extends ReentrantLock implements Serializable {
}
```

一个 ConcurrentHashMap 里包含一个 Segment 数组。**Segment 的结构和HashMap类似，是一种数组和链表结构**，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。

#### JDK1.8 （上面有示意图）

ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。

synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。

解决hash冲突的办法：

（1）开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）

（2）再哈希法

（3）链地址法

（4）建立一个公共溢出区

