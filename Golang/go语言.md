#                                    **go语言**

## 1、简介

（1）Go语言被设计成一门应用于搭载Web服务器，存储集群或者类似用途的巨型中央服务器的系统编程语言，

（2）对于高性能分布式系统邻域而言，Go语言无疑比大多数其他语言有着更高的开发效率，他提供了海量的并行的支持，这对于游戏服务端的开发是再好不过了。

## 2、语言结构

Go语言的基础组成部分：

(1)包声明（package 包名）：Go程序是用包package来组织的，必须在源文件非注释第一行表明该文件属于哪个包，如：package main表示一个可独立执行的程序，每个Go应用程序都包含一个名为main的包，一个可执行程序有且仅有一个main包，通过import关键字来导入其他非main包，可以通过import关键字单个导入

import "fmt"

import "io"

也可以同时导入多个

import(

​	"fmt"

​	"math"

)

(2)引入包（import “包名”）：告诉编译器需要使用哪个包（的函数，或其他元素），如import “fmt”，告诉编译器需要使用fmt包，实现格式化IO（输入/输出）的函数，包引入一般为：项目名/包名 import "test/controllers"

方法的调用为：包名.方法名()  controllers.Test()

(3)函数：通过func关键字来进行函数的声明，Go语言中，使用大小写来决定该常量、变量、类型、接口、结构体或者函数是否可以被外部包所调用

函数名首字母小写即为private

func getId(){}

函数名首字母大写即为public 

func Printf(){}

(4)变量：通过const关键字来进行常量的定义，通过在函数体外部使用var关键字来进行全局变量的声明和赋值

通过type关键字来进行结构体（struct）和接口（interface）的声明

(5)语句&表达式、(6)注释

## 3、基础语法

（1）Go标记

程序可以有多个标记组成，可以是关键字，标识符，常量，字符串，符号。

（2）行分隔符

在Go程序中，一行代表一个语句的结束。如果打算将多个语句写在同一行，则必须使用；认为区分，一般不提倡这种写法。

（3）标识符

标识符用来命名变量、类型等程序实体，一个标识符实际上就是一个或者多个字母和数字、下划线组成的序列，但是第一个字符必须是字符或下划线，而不能是数字

（4）关键字

| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |

（5）空格

变量的声明必须使用空格隔开

## 4、数据类型

在Go语言中，数据类型用于声明函数和变量

数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。

（1）布尔型：布尔型的值只是可以是常量true或者false

（2）数字类型：整型int和浮点型float32、float64，Go语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。

（3）字符串类型：字符串就是一串固定长度的字符连接起来的字符序列，Go的字符串是由单个字节连接起来的，Go语言的字符串的字节使用UTF-8编码标识Unicode文本

（4）派生类型：

包括：（a）指针类型（Pointer）（b）数组类型（c）结构化类型(struct)（d）Channel类型（e）函数类型

（f）切片类型（g）接口类型（h）Map类型

1.9版本对于数字类型，无需定义int及float32、float64，系统会自动识别

## 5、变量

Go语言变量名由字母、数字、下划线组成，其中首个字符不能为数字

声明变量的一般形式是使用var关键字：var identifier type

（1），指明变量类型，声明后若不赋值，使用默认值

var v_name v_type

v_name = vale

（2）根据值自行判定变量的类型

var v_name = value

（3）省略var，注意：=左侧的变量不应该是已经声明过的，否则会导致编译错误。如果声明一个局部变量却没有在相同的代码块中使用它，同样会导致编译错误。但是局部变量是允许声明但不使用。

v_name := value

这是使用变量的首先形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符：=可以高效地创建一个新的变量，称之为初始化声明。

（4）多变量声明

//类型相同多个变量，非全局变量

同一类型的多个变量可以声明在同一行var vname1,vname2,vname3 type

var a,b,c int

多变量可以在同一行进行赋值，如：

 vname1,vname2,vname3 = v1,v2,v3

//不需要显示声明类型，自动推断

var vname1,vname2,vname3 = v1,v2,v3

出现在：=左侧的变量不应该是已经声明过的，否则会导致编译错误。

vname1,vname2,vname3 ：= v1,v2,v3

//这种因式分解关键字的写法一般用于声明全局变量

var(

​	vname1 v_type1

​	vanem2 v_type2)

如果想要交换两个变量的值，则可以简单的使用a,b = b,a，两个变量的类型必须是相同的。

空白标识符'_'被用于抛弃值，如值5在_:,b = 5,7

_实际上是一个只写变量，你不能得到它的值，这样做是因为Go语言中你必须使用所有被声明的变量，但有时并不需要使用从一个函数得到的所有返回值。

（5）值类型，引用类型

所有像int、float、bool和string这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值

当使用等号=将一个变量的值赋值给另一个变量时，如j=i，实际上是在内存中将i的值进行了拷贝，可以通过&i来获取变量i的内存地址，值类型变量的值是存储在栈中的。

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量r1存储的是r1的值所在的内存地址（数字），或内存地址中第一个字所在的位置。内存地址称为指针。

当使用赋值语句r2 = r1 的时候，只有引用（地址）被复制

如果r1的值改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2也会受到影响。

## 6、常量

常量是一个简单的值的标识符，在程序运行的时候，不会被修改的量。常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串。常量的定义格式：

const identifier [type] = value

可以省略类型说明符[type]，因为编译器可以根据变量的值来推断其类型

iota，特殊的常量，可以认为是一个可以被编译器修改的常量。

iota在const关键字出现时将被重置为0（const内部的第一行之前），const中每新增一行常量声明将使iota计数一次（iota可理解为const语句块中的行索引）。

iota可以被用作枚举值

const(

​	a = iota

​	b = iota

​	c = iota

 )

第一个iota等于0，每当iota在新的一行被使用的时候，它的值都会自动增加1；所以a = 0,b = 1,c = 2，可以简写如下形式：

const(

​	a = iota

​	b

​	c

)

在定义常量组时，如果不提供初始值，则表示将使用上行的表达式

const(

​	a = 1

​	b

​	c

)

此时b,c 的值也为1.

## 7、运算符

Go语言内置运算符有：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符、其他运算符

下表列出了Go语言的其他运算符。

| 运算符 | 描述             | 实例                       |
| ------ | ---------------- | -------------------------- |
| &      | 返回变量存储地址 | &a; 将给出变量的实际地址。 |
| *      | 指针变量。       | *a; 是一个指针变量         |

指针变量*和地址值&的区别：指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字。当变量前面有*标识的时候，才等同于&的用法，否则会直接输出一个整型数字。

## 8、条件语句

条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为true来决定是否执行指定语句，并在条件为false的情况下执行另外的语句。

Go 语言提供了以下几种条件判断语句：

| 语句                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [if 语句](http://www.runoob.com/go/go-if-statement.html)     | **if 语句** 由一个布尔表达式后紧跟一个或多个语句组成。       |
| [if...else 语句](http://www.runoob.com/go/go-if-else-statement.html) | **if 语句** 后可以使用可选的 **else 语句**, else 语句中的表达式在布尔表达式为 false 时执行。 |
| [if 嵌套语句](http://www.runoob.com/go/go-nested-if-statements.html) | 你可以在 **if** 或 **else if** 语句中嵌入一个或多个 **if** 或 **else if** 语句。 |
| [switch 语句](http://www.runoob.com/go/go-switch-statement.html) | **switch** 语句用于基于不同条件执行不同动作。                |
| [select 语句](http://www.runoob.com/go/go-select-statement.html) | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 |

## 9、循环语句

Go 语言提供了以下几种类型循环处理语句：

| 循环类型                                                  | 描述                                 |
| --------------------------------------------------------- | ------------------------------------ |
| [for 循环](http://www.runoob.com/go/go-for-loop.html)     | 重复执行语句块                       |
| [循环嵌套](http://www.runoob.com/go/go-nested-loops.html) | 在 for 循环中嵌套一个或多个 for 循环 |

------

循环控制语句

循环控制语句可以控制循环体内语句的执行过程。

GO 语言支持以下几种循环控制语句：

| 控制语句                                                     | 描述                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| [break 语句](http://www.runoob.com/go/go-break-statement.html) | 经常用于中断当前 for 循环或跳出 switch 语句      |
| [continue 语句](http://www.runoob.com/go/go-continue-statement.html) | 跳过当前循环的剩余语句，然后继续进行下一轮循环。 |
| [goto 语句](http://www.runoob.com/go/go-goto-statement.html) | 将控制转移到被标记的语句。                       |

------

无限循环

如果循环中条件语句永远不为 false 则会进行无限循环

## 10、函数

函数是基本代码块，用于执行一个任务。

（1）、函数定义

func function_name([parameter list]) [return_types]{

​    函数体

}

函数定义解析：

func :函数由func开始声明

function_name：函数名称，函数名和参数列表一起构成了函数签名。

parameter list：参数列表，参数就像是一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序及参数个数，参数是可选的，也就是说函数可以不包含参数

return_types：返回类型，函数返回一系列值。retuern_types是该列值的数据类型。有些功能不需要返回值，这些情况下return_types不是必须的。

函数体：函数定义的代码集合

（2）函数调用

当创建函数时，你定义了函数需要什么，通过调用该函数来执行指定任务。调用函数，向函数传递参数，并返回值。

（3）函数参数

函数如果使用参数，该变量可称为函数的形参。形参就像定义在函数体内的局部变量。

调用函数，可以通过两种方式来传递参数：

| 传递类型 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 值传递   | 值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 |
| 引用传递 | 引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行修改，将影响到实际参数。 |

默认情况下，Go语言使用的是值传递，即在调用过程中不会影响到实际参数。

（4）函数用法

| 函数用法                                                     | 描述                               |
| ------------------------------------------------------------ | ---------------------------------- |
| [函数作为值](http://www.runoob.com/go/go-function-as-values.html) | 函数定义后可作为值来使用           |
| [闭包](http://www.runoob.com/go/go-function-closures.html)   | 闭包是匿名函数，可在动态编程中使用 |
| [方法](http://www.runoob.com/go/go-method.html)              | 方法就是一个包含了接受者的函数     |

## 11、变量作用域

作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。

Go语言中变量可以在三个地方声明：

函数内定义的变量称为**局部变量**

函数外定义的变量称为**全局变量**

函数定义中的变量称为**形式参数**

（1）局部变量：在函数体内声明的变量称之为局部变量，他们的作用域只在函数体内，参数和返回值变量也是局部变量。

（2）全局变量：在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。

全局变量可以在任何函数中使用。

（3）形式参数：作为函数的局部变量来使用。

## 12、数组

数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。

数组元素可以通过索引（位置）来读取（或者修改），索引从0开始，第一个索引为0，第一个索引为1，以此类推。

（1）声明数组

Go语言数组声明需要指定元素类型及元素个数，语法格式如下：

var variable_name [size] variable_type

var balance[10] float32

（2）初始化数组

var balance = [5]float32{100.0, 2.0, 3.4,7.0,50.2}

初始化数组中{}中的元素个数不能大于[]中的数字

如果忽略[]中的数字不设置数组的大小，Go语言会根据元素的个数来设置数组的大小。

var balance = [...]float32{100.0, 2.0, 3.4,7.0,50.2}

（3）访问数组元素

数组元素可以通过索引（位置）来读取，格式为数组后加中括号，中括号中为索引得到值。

## 13、指针

变量是一种使用方便的占位符，用于引用计算机内存地址。Go语言的取地址符是&，放到一个变量前使用就会返回相应变量的内存地址。

（1）什么是指针

一个指针变量指向了一个值的内存地址。

指针声明格式如下：

var var_name *var-type

var-type为指针类型，var_name 为指针变量名，*号用于指定变量是作为一个指针。

var ip *int     //指向整型

var fp *float32 //指向浮点型

（2）如何使用指针

指针使用流程：

a、定义指针变量

b、为指针变量赋值

c、访问指针变量中指向地址的值

（3）空指针

当一个指针被定义后没有分配到任何变量时，它的值为nil。nil指针也称为空指针。

nil在概念上和其他语言的null、None、nil、NULL一样，都指代零值或空值。

一个指针变量通常缩写为ptr。

## 14、结构体

Go语言中数组可以存储同一类型的数据，但在结构体中我们可以不同项定义不同的数据类型。

结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。

结构体表示一项纪录。

（1）定义结构体

结构体定义需要使用type和struct语句。struct语句定义一个新的数据类型，结构体中有一个或多个成员，type设定结构体的名称，结构体的格式如下：

type struct_variable_type struct{

​	member definition;

​	member definition;

​	....

​	member definition;

}

一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：

variable_name := structure_variable_type{value1,value2.....valuen}

variable_name := structure_variable_type{key1：value1,key2：value2.....，keyn：valuen}

（2）访问结构体成员

格式为：结构体.成员名

（3）结构体方法

结构体方法的声明和普通函数的声明类似，只是在函数名字前面多加了一个参数。这个参数把这个方法绑定到这个参数对应的类型上。

```go
type Rect struct {
    width, length float64
}
//结构体方法
func (rect Rect) area() float64 {
    return rect.width * rect.length
}
```

（4）结构体的内嵌类型

我们可以在一个结构体内部定义另外一个结构体类型的成员，例如iPhone也是Phone，我们看下例子：

```go
type Phone struct {
    price int
    color string
}
type IPhone struct {
    phone Phone
    model string
}
```

## 15、切片

Go语言切片是对数组的抽象。

Go语言数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片（“动态数组”），与数组相比切片的长度是不固定的，可以追加元素，在追加时可以使切片的容量增大。

（1）定义切片

var identifier [] type

切片不需要说明长度

或使用make()函数来创建切片

var slice1 []type = make([]type, len)

也可以简写为

slice1 := make([]type, len)

也可以指定容量，其中capacity为可选参数。

make([]T, length, capacity)       这里length是数组的长度并且也是切片的初始长度。

（2）切片初始化

s := []int{1,2,3}        //直接初始化切片，[]int表示切片类型，{1,2,3}初始化值依次是1,2,3

s := arr[:]                  // 初始化切片s，是数组arr的引用

s := arr[startIndex:endIndex]                     //将arr中从下标startIndex到endIndex-1的元素创建为一个新的切片

s := arr[startIndex:]         //缺省endIndex时，将表示一直到arr的最后一个元素

s := arr[:endIndex]         //缺省startIndex时，将表示从arr的第一个元素开始

（3）len()和cap()函数

切片是可索引的，并且可以由len()方法获取长度

切片提供了计算容量的方法cap（）可以测量切片最长可以达到多少。

（4）空(nil)切片

一个切片在未初始化之前默认为nil，长度为0.

（5）切片截取

可以通过设置下限和上限来截取切片[lower-bound:upper-bound]

（6）append（）和copy（）函数

如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。

## 16、语言范围

Go语言中range关键字用于for循环中迭代数组（array）、切片（slice）、通道（channel）或集合（map）的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回key-value对的key值

## 17、Map（集合）

Map是一种无序的键值对的集合，Map最重要的一点是通过key来快速检索数据，key类似于索引，指向数据的值。Map是一种集合，所以我们可以像迭代数组和切片那样迭代它，不过，Map是无序的，我们无法决定他的返回顺序。这是因为Map是使用Hash表来实现的。

（1）定义Map

可以使用内建函数make，也可以使用map关键字来定义Map:

var map_variable map[key_data_type]value_data_type              //声明变量，默认map是nil

map_variable := make(map[key_data_type]value_data_type)     //使用make函数

如果不初始化map，那么就会创建一个nil map。nil map不能用来存放键值对

（2）delete（）函数

delete（）函数用于删除集合的元素，参数是map和其他对应的key。

## 18、递归函数

递归就是在运行的过程中调用自己。Go语言支持递归，使用递归的时候需要设置退出条件，否则递归将陷入无限循环中。

递归的语法格式如下：

func recursion(){

​	recursion()   //函数调用自身

}

func main(){

​	recursion()

}

## 19、类型转换

类型转换用于将一种数据类型的变量转换为另外一种类型的变量。Go语言类型转换基本格式如下：

type_name(expression)

type_name为类型，expression为表达式

## 20、语言接口

Go语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

//定义接口

type interface_name interface{

​	method_name1 [return_type]

​	method_name2 [return_type]

​	method_name3 [return_type]

​	...........

​	method_namen [return_type]

}

//定义结构体

type struct_name struct {

​	/*variables*/

}

//实现接口方法

func(struct_name_variable struct_name) method_name1() [reyurn_type]{

​	/*方法实现*/

}

......

func(struct_name_variable struct_name) method_namen() [reyurn_type]{

​	/*方法实现*/

}

## 21、错误处理

Go语言通过内置的错误接口提供了非常简单的错误处理机制

error类型是一个接口类型，定义格式为：

type error interface{

​	Error() string

}

我们可以在编码中通过实现error接口类型来生成错误信息。

函数通常在最后的返回值中返回错误信息，使用errors.New可返回一个错误的信息。

panic和recover是Go的两个内置函数，这两个内置函数用于处理Go运行时的错误，panic用于主动抛出错误，recover用于捕获panic抛出的错误。

引发panic有两种情况，一是程序主动调用，二是程序产生运行时错误，由运行时检测并退出。

发生panic后，程序会调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行率到最外层函数。

panic不但可以在函数工作流程中抛出，在defer逻辑里也可以再次调用panic或抛出panic。defer里面的panic能够被后续执行的defer捕获。

recover用来捕获panic，阻止panic继续向上传递。recover（）和defer一起使用，但是defer只有在后面的函数体内直接被用掉才能捕获panic来终止异常，否则返回nil，异常继续向外传递。

## 22、并发

Go语言支持并发，我们只需要通过go关键字来开启goroutine即可。

goroutine是轻量级线程，goroutine的本质是协程，是实现并行计算的核心，goroutine的调度是由Golang运行时进行管理的。

goroutine语法格式：

go 函数名(参数列表)

Go允许使用go语句开启一个新的运行期线程，即goroutine，以一个不同的、新创建的goroutine来执行一个函数，同一个程序中的所有goroutine共享一个地址空间。并且它是处于异步方式运行，你不需要等它运行完成以后再执行以后的代码。

**并发**：一个CPU上能同时执行多项任务，在很短时间内，CPU来回切换任务执行（在某段很短时间内执行程序a，然后又迅速得到切换程序b去执行），有时间上的重叠（宏观上是同时的，微观上扔是顺序执行）。这样看起来多个任务像是同时执行。

**并行**：当系统有多个CPU时，每个CPU同一时刻都运行任务，互补抢占自己所在的CPU资源，同时进行，称为并行。

**进程**：CPU在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的context--上下文），直接切换到下一个程序，就会丢失上一个程序的一些列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单位（也就是说程序运行的一个实体）

**线程**：CPU切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而再次调度需要内核态都需要读取用户态的数据，进程一旦多起来，CPU调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会那么像进程切换那么耗费资源。

**协程**：协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前的保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。线程和进程的操作是由程序触发系统的接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。

## 23、通道

（1）通道（channel）是用来传递数据的一个数据结构。

通道可用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯。操作符<-用于指定通道的方向，发送或接收。如果未指定通道的方向，则为双向通道。

ch <- v        //把v发送到通道ch

v := <-ch     //把ch接收的数据赋值给v

声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建。

ch := make(chan int)

默认情况下，通道是不带缓冲区的，发送端发送数据，同时必须有接收端相应的接收数据。

（2）通道缓冲区

通道可以设置缓冲区。通过make的第二个参数指定缓冲区大小：

ch := make(chan int,100)

带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待等待接收端去获取数据，而不是立刻需要接收端去获取数据。

不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据端就无法再发送数据了。

向channel传入数据，CHAN <- DATA，CHAN指的是目的channel即收集数据的一方，DATA则是要传的数据

从channel读取数据，DATA：= <-CHAN，和向channel传入数据相反，在数据传送箭头的右侧的是channel，形象地展现了数据从隧道流出到变量里。

（3）遍历通道和关闭通道

Go通过range关键字来实现遍历读取到的数据，类似于数组和切片，格式如下：

v，ok := <- ch

如果通道接收不到数据后ok就为false，这时通道就可以使用close（）函数来关闭。（）

（4）make和new的区别

make和new都是Go语言的内置函数，主要用来创建分配类型内存，

new接收一个参数，这个参数是一个类型，分配好内存后，返回一个指向该类型内存地址的指针，同时把分配的内存置为零，也就是类型的零值。

make也用于内存分配，但是和new不同，它只用于chan、map以及切片的内存创建，而且它返回的类型就是这三个类型的本身，而不是他们的指针类型，因为这三种类型是引用类型，所以必须的初始化。

## 24、Golang定时器

两种类型的定时器timer和ticker，两者的区别如下：

**ticker**

package main

import (
        "fmt"

        "time"
)


func main() {

        d := time.Duration(time.Second*2)
    
        t := time.NewTicker(d)
        defer t.Stop()
    
        for {
                <- t.C
    
                fmt.Println("timeout...")
        }
}

输出结果为

output:

timeout…

timeout…

timeout…

**解析**

ticker只要定义完成，从此刻开始计时，不需要任何其他的操作，每隔固定时间都会触发。

**timer**


package main

import (
        "fmt"

        "time"
)


func main() {

        d := time.Duration(time.Second*2)
    
        t := time.NewTimer(d)
        defer t.Stop()
    
        for {
                <- t.C
    
                fmt.Println("timeout...")
    	// need reset
    	t.Reset(time.Second*2)
        }
        }

output:

timeout…

timeout…

timeout…

解析

使用timer定时器，超时后需要重置，才能继续触发。